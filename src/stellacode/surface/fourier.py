import typing as tp
from os import sep

import matplotlib.pyplot as plt
import numpy as onp
from concave_hull import concave_hull
from jax.typing import ArrayLike
from scipy.interpolate import CubicSpline, interp1d
from scipy.io import netcdf_file
from scipy.spatial import ConvexHull

from stellacode import np
from stellacode.surface.utils import fourier_coefficients
from stellacode.tools.bnorm import get_bnorm
from stellacode.tools.vmec import VMECIO

from .abstract_surface import AbstractSurfaceFactory, IntegrationParams, Surface
from .cylindrical import CylindricalSurface
from .tore import ToroidalSurface
from .utils import (
    cartesian_to_cylindrical,
    cartesian_to_shifted_cylindrical,
    cartesian_to_toroidal,
    from_polar,
    to_polar,
)


class FourierSurfaceFactory(AbstractSurfaceFactory):
    """Generate a toroidal surface with Fourier coefficients

    Args:
        * nfp: number of field periods
        * mf: Fourier harmonic numbers in the poloidal direction
        * nf: Fourier harmonic numbers in the toroidal direction
        * Rmn: fourier coefficients for the radius in cylindrical coordinates
        * Zmn: fourier coefficients for the height in cylindrical coordinates
        * file_path: path to the file containing the Fourier coefficients
    """

    nfp: int
    mf: ArrayLike
    nf: ArrayLike
    Rmn: ArrayLike
    Zmn: ArrayLike
    Raxis: tp.Optional[ArrayLike] = None
    Zaxis: tp.Optional[ArrayLike] = None
    minor_radius: tp.Optional[ArrayLike] = None
    file_path: str

    trainable_params: tp.List[str] = [
        "Rmn",
        "Zmn",
    ]

    @classmethod
    def from_file(
        cls,
        path_surf: str,
        integration_par: IntegrationParams,
        n_fp=1,
        surface_label: int = -1,
    ):
        """
        This function returns a Surface_Fourier object defined by a file.
        Three kinds of file are currently supported :
        - wout nc files generated by VMEC (for plasma surfaces)
        - nescin files generated by regcoil
        - text files (see example in data/li383)

        load file with the format m,n,Rmn,Zmn
        """

        Raxis = None
        Zaxis = None
        minor_radius = None

        if path_surf[-3::] == ".nc":
            vmec = VMECIO.from_grid(path_surf)

            # params
            n_fp = vmec.nfp
            m = vmec.get_var("xm", int)
            n = -vmec.get_var("xn", int) / n_fp

            # surface
            Rmn = vmec.get_var("rmnc", float)[surface_label]
            Zmn = vmec.get_var("zmns", float)[surface_label]

            # magnetic axis
            Raxis, Zaxis = vmec.get_magnetic_axis()

            # minor radius
            minor_radius = vmec.get_var("Aminor_p", float)

        elif path_surf.rpartition(sep)[-1][:6:] == "nescin":
            with open(path_surf, "r") as f:
                line = f.readline()
                while "------ Current Surface:" not in line:
                    line = f.readline()
                line = f.readline()
                num_modes = int(f.readline())

                f.readline()
                f.readline()

                data = []
                for _ in range(num_modes):
                    data.append(str.split(f.readline()))
                adata = np.array(data, dtype="float64")
                m, n, Rmn, Zmn = adata[:, 0], adata[:,
                                                    1], adata[:, 2], adata[:, 3]

        else:
            data = []
            with open(path_surf, "r") as f:
                next(f)
                for line in f:
                    data.append(str.split(line))

            adata = np.array(data, dtype="float64")
            m, n, Rmn, Zmn = adata[:, 0], adata[:, 1], adata[:, 2], adata[:, 3]

        return cls(
            Rmn=Rmn,
            Zmn=Zmn,
            mf=m,
            nf=n,
            Raxis=Raxis,
            Zaxis=Zaxis,
            minor_radius=minor_radius,
            integration_par=integration_par,
            nfp=n_fp,
            file_path=path_surf,
        )

    def set_trainable(self, arg: str):
        assert arg in vars(self)
        assert arg != 'trainable_params'
        self.trainable_params.append(arg)

    def get_xyz(self, uv):
        angle = 2 * np.pi * (uv[0] * self.mf + uv[1] * self.nf)
        R = np.tensordot(self.Rmn, np.cos(angle), 1)
        Z = np.tensordot(self.Zmn, np.sin(angle), 1)
        phi = 2 * np.pi * uv[1] / self.nfp
        return np.array([R * np.cos(phi), R * np.sin(phi), Z])

    def get_major_radius(self):
        assert self.mf[0] == 0 and self.nf[0] == 0
        return self.Rmn[0]

    def plot_cross_sections(
        self,
        num_cyl: tp.Optional[int] = None,
        num: int = 5,
        convex_envelope: bool = True,
        concave_envelope: bool = False,
        scale_envelope: float = 1.0,
        ax=None,
    ):
        """
        Plot cross-sections of the surface factory.

        Args:
            num_cyl (int, optional): Number of cylindrical coordinates to plot.
            num (int, optional): Number of cross-sections to plot.
            convex_envelope (bool, optional): Plot convex envelope.
            concave_envelope (bool, optional): Plot concave envelope.
            scale_envelope (float, optional): Scale factor for envelope.
            ax (Axes, optional): Matplotlib axes object to plot on.

        Returns:
            Axes: Matplotlib axes object.
        """
        import matplotlib.pyplot as plt

        # Create axes if not provided
        if ax is None:
            fig, ax = plt.subplots(subplot_kw={"projection": "polar"})

        # Define u and v coordinates
        u = np.linspace(0, 1, 100, endpoint=True)
        v = np.linspace(0, 1, num, endpoint=True)
        ugrid, vgrid = np.meshgrid(u, v, indexing="ij")

        # Create surface instance and calculate xyz coordinates
        surf = self()
        xyz = self.get_xyz_on_grid(np.stack((ugrid, vgrid)))

        # Calculate radial and theta coordinates
        rtheta = surf._get_rtheta(xyz=xyz, num_cyl=num_cyl)

        # Plot cross-sections
        for i in range(num):
            rphi = np.concatenate((rtheta[:, i, :], rtheta[:, i, :]), axis=0)
            ax.plot(
                rphi[:, 1],
                rphi[:, 0],
                c=[0, 0] + [float((i + 1) / (num + 1))],
            )

        # Plot convex envelope if requested
        if convex_envelope:
            env, rtheta = surf.get_envelope(num_cyl=num_cyl, convex=True)
            ax.plot(env[:, 1], env[:, 0] * scale_envelope, c="r", linewidth=3)

        # Plot concave envelope if requested
        if concave_envelope:
            env, rtheta = surf.get_envelope(num_cyl=num_cyl, convex=False)
            ax.plot(env[:, 1], env[:, 0] * scale_envelope, c="g", linewidth=3)

        return ax.get_figure(), ax

    def __call__(self, **kwargs):
        """
        Call the surface factory to create a new instance of the surface.

        Args:
            **kwargs: Additional parameters to override the default parameters.

        Returns:
            surface: A new instance of the FourierSurface class.
        """

        # Call the parent class to get the initial surface
        surface = super().__call__(**kwargs)

        # Create a new instance of the FourierSurface class with overridden parameters
        surface = FourierSurface(
            major_radius=self.get_major_radius(),  # Get the major radius
            file_path=self.file_path,  # Use the file path
            **dict(surface),  # Add any additional parameters
            nfp=self.nfp,  # Use the number of field periods
            Raxis=self.Raxis,  # Use the major radius axis
            Zaxis=self.Zaxis,  # Use the minor radius axis
            minor_radius=self.minor_radius,  # Use the minor radius
        )

        return surface


class FourierSurface(Surface):
    """
    Represent a toroidal surface with Fourier coefficients.

    Args:
        * major_radius: major radius of the surface
        * nfp: number of field periods
        * file_path: path to the file containing the Fourier coefficients
    """

    major_radius: ArrayLike
    minor_radius: tp.Optional[ArrayLike] = None
    nfp: int
    Raxis: tp.Optional[ArrayLike] = None
    Zaxis: tp.Optional[ArrayLike] = None
    file_path: str

    def integrate(self, field):
        return super().integrate(field) * self.nfp

    def get_major_radius(self):
        return self.major_radius

    def get_minor_radius(self, vmec=True):
        """
        Get the minor radius :
        - from vmec file
        - as the maximum value of the radius in toroidal coords
        """
        if vmec:
            return self.minor_radius
        else:
            return np.max(self.cartesian_to_toroidal()[:, :, 0])

    def cartesian_to_cylindrical(self):
        return cartesian_to_cylindrical(xyz=self.xyz)

    def cartesian_to_toroidal(self, xyz=None):
        if xyz is None:
            xyz = self.xyz
        return cartesian_to_toroidal(
            xyz=xyz,
            tore_radius=self.Raxis.mean()
        )

    def cartesian_to_shifted_cylindrical(self, xyz=None, num_cyl: int = 1, angle: float = 0.0):
        if xyz is None:
            xyz = self.xyz
        num_tor = xyz.shape[1]
        num_pol = xyz.shape[0]
        points = np.linspace(0, num_tor, num_cyl + 1, dtype=int)
        rphiz_l = []
        for ind, first, last in zip(range(num_cyl), points[:-1], points[1:]):
            xyz_ = xyz[:, first:last]
            cyl_angle = (
                np.pi / 2 - (np.pi / 2 + np.pi * (-2 * ind + 1) /
                             (self.nfp * num_cyl)) + np.pi / (self.nfp * num_cyl)
            )
            surf = CylindricalSurface(
                integration_par=IntegrationParams(
                    num_points_u=num_pol, num_points_v=last - first),
                make_joints=False,
                axis_angle=cyl_angle,
                nfp=num_cyl * self.nfp,
                distance=self.get_major_radius(),
            )
            rphiz2 = surf.to_cylindrical(xyz_)
            rphiz = rphiz2.at[..., 1].set(rphiz2[..., 1] - np.pi / 2)
            # fig, ax = plt.subplots(subplot_kw={"projection": "polar"})
            # ax.plot(rphiz[:,0, 1], rphiz[:,0, 0])
            # plt.show()
            # surf().plot()
            rphiz_l.append(rphiz)

        rphiz_l = onp.concatenate(rphiz_l, axis=1)
        # self.plot()
        # import pdb;pdb.set_trace()
        # rphiz_l = np.reshape(rphiz_l, (-1, 3))
        # fig, ax = plt.subplots(subplot_kw={"projection": "polar"})
        # ax.scatter(rphiz_l[:, 1], rphiz_l[:, 0])
        # plt.show()

        return rphiz_l

    def _get_rtheta(self, xyz=None, num_cyl: tp.Optional[int] = None, angle: float = 0.0):
        """
        Get radial and theta coordinates of the given xyz coordinates.

        Parameters
        ----------
        xyz : ArrayLike, optional
            Coordinates in cartesian coordinates. Defaults to self.xyz.
        num_cyl : int, optional
            Number of cylindrical coordinates. Defaults to None.
        angle : float, optional
            Angle of rotation of the cylindrical coordinates. Defaults to 0.0.

        Returns
        -------
        ndarray
            Array of radial and theta coordinates.
        """
        # If xyz is not provided, use self.xyz
        if xyz is None:
            xyz = self.xyz

        # If num_cyl is not provided, use toroidal coordinates
        if num_cyl is None:
            rtheta = self.cartesian_to_toroidal(xyz=xyz)[..., :2]
        else:
            # If num_cyl is provided, use shifted cylindrical coordinates
            rtheta = self.cartesian_to_shifted_cylindrical(
                xyz=xyz, num_cyl=num_cyl, angle=angle)[..., :2]

        # Return radial and theta coordinates
        return rtheta

    def get_envelope(
        self,
        num_cyl: tp.Optional[int] = None,
        polar_coords: bool = True,
        convex: bool = True,
        angle: float = 0.0,
    ):
        """
        Return a convex or concave hull of the poloidal plane at a given angle.

        Args:
            *num_cyl: number of cylinders if pwc
            *polar_coords: whether to return polar or cartesian coords
            *convex: whether compute a convex or concave hull
            *angle: determine the poloidal plane
        """
        # generate points in polar coordinates
        rtheta = self._get_rtheta(num_cyl=num_cyl, angle=angle)
        points = np.reshape(rtheta, (-1, 2))

        # convert from polar to cartesian coordinates
        xy_points = np.stack(from_polar(points[:, 0], points[:, 1])).T

        if convex:
            hull = ConvexHull(xy_points)
            sel_xy_points = xy_points[hull.vertices, :]
        else:
            sel_xy_points = concave_hull(
                xy_points, length_threshold=np.linalg.norm(xy_points[1] - xy_points[0]) * 4)
            sel_xy_points = np.stack(sel_xy_points)

        if not polar_coords:
            return sel_xy_points, points
        else:
            # convert from cartesian to polar coordinates
            r, th = to_polar(sel_xy_points[:, 0], sel_xy_points[:, 1])
            rth = np.stack((r, th), axis=1)
            rth = rth[rth[:, 1].argsort()]
            return np.concatenate((rth, rth[:1])), points

    def get_envelope_fourier_coeff(
        self,
        num_cyl: tp.Optional[int] = None,
        num_coeff: int = 5,
        convex: bool = False,
        angle: float = 0.0,
    ):
        # retrieve envelope data
        xy = self.get_envelope(
            num_cyl=num_cyl, polar_coords=False, convex=convex, angle=angle)[0]

        # import matplotlib.pyplot as plt;import seaborn as sns;import matplotlib;matplotlib.use('TkAgg')
        # plt.scatter(xy[:, 0], xy[:, 1]);plt.show()
        # import pdb;pdb.set_trace()

        # convert to polar coordinates
        r, th = to_polar(xy[:, 0], xy[:, 1])

        # sort the coordinates according to theta angle
        sorted_indices = th.argsort()
        xy = xy[sorted_indices]
        th = th[sorted_indices]

        # extend the coordinates and angles for periodicity
        xy = np.concatenate((xy, xy[:1]))
        th = np.concatenate((th, th[:1] + 2 * np.pi))
        # rth_s = rth_s.at[-1, 1].set(rth_s[-1, 1] + 2 * np.pi)

        # interpolate to create a continuous function for r(theta)
        # interp = interp1d(th, xy, kind="linear", axis=0)
        interp = CubicSpline(th, xy, bc_type="periodic")

        def fun(theta):
            return to_polar(*interp(theta))[0]

        # fun = lambda x: onp.interp(x, rth_s[:, 1], rth_s[:, 0], period=2*np.pi)
        # import pdb;pdb.set_trace()
        # theta = np.linspace(0,2*np.pi, 50)
        # xy =interp(theta)
        # import matplotlib.pyplot as plt;import seaborn as sns;import matplotlib;matplotlib.use('TkAgg')
        # plt.scatter(xy[:, 0], xy[:, 1]);plt.show()

        return fourier_coefficients(th.min(), th.min() + 2 * np.pi, num_coeff, fun)

    def get_surface_envelope(
        self,
        num_cyl: tp.Optional[int] = None,
        num_coeff: int = 5,
        convex: bool = False,
        angle: float = 0.0,
    ) -> tp.Union[ToroidalSurface, CylindricalSurface]:
        """
        Return a surface with Fourier coefficients that match the envelope.

        Args:
            num_cyl: the number of cylinders if the surface is piecewise cylindrical
            num_coeff: the number of Fourier coefficients to use
            convex: whether to compute a convex envelope
            angle: the angle of the poloidal plane

        Returns:
            A Surface instance with Fourier coefficients matching the envelope of this surface.
            If `num_cyl` is None, returns a `ToroidalSurface` instance. Otherwise, returns a
            `CylindricalSurface` instance.
        """
        minor_radius, coefs = self.get_envelope_fourier_coeff(
            num_cyl=num_cyl, num_coeff=num_coeff, convex=convex, angle=angle
        )
        if num_cyl is None:
            return ToroidalSurface(
                integration_par=self.integration_par,
                nfp=self.nfp,
                major_radius=self.get_major_radius(),
                minor_radius=minor_radius,
                fourier_coeffs=coefs / minor_radius,
            )
        else:
            return CylindricalSurface(
                integration_par=self.integration_par,
                nfp=self.nfp * num_cyl,
                distance=self.get_major_radius(),
                radius=minor_radius,
                fourier_coeffs=coefs / minor_radius,
            )

    def get_gt_b_field(self, surface_labels: int = -1, b_norm_file: tp.Optional[str] = None):
        """
        Returns the magnetic field in Cartesian coordinates on a given closed flux surface.
        If surface_labels is a list of integers, the magnetic field on all surfaces with these labels is returned.
        If b_norm_file is provided, add the normal magnetic field component
        component of the magnetic field on the plasma surface.

        Parameters
        ----------
        surface_labels : int or list of int
            The labels of the surfaces to consider.
        b_norm_file : str, optional
            The path to a file containing the normal component of the magnetic field.

        Returns
        -------
        numpy.ndarray
            The magnetic field on the given surfaces.
        """
        # Load the VMECIO object
        vmec = VMECIO.from_grid(
            self.file_path,
            ntheta=self.integration_par.num_points_u,
            nzeta=self.integration_par.num_points_v,
            surface_label=surface_labels,
        )

        # If surface_labels is an integer, only consider the surface with this label
        if isinstance(surface_labels, int):
            b_field = vmec.b_cartesian[0]
        # If surface_labels is a list of integers, consider all surfaces with these labels
        else:
            b_field = vmec.b_cartesian[surface_labels]

        # If a normal component of the magnetic field is provided, add it to the magnetic field
        if b_norm_file is not None:
            # Load the normal component of the magnetic field
            bnorm = -vmec.scale_bnorm(get_bnorm(b_norm_file, self))
            # Add the normal component
            b_field += bnorm[..., None] * self.normal_unit

        return b_field
