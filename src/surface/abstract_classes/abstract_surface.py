from abc import ABCMeta, abstractmethod


class Surface(metaclass=ABCMeta):
    """A class used to represent an abstract toroidal surface.

    This class can be used to define other child classes.
    If those classes have all of the abstract methods defined here, the Stellacode should work with them.

    This class also implements some concrete methods.
    They allow for the computation of the magnetic field generated by a current carried by the surface.
    They allow for visualization tools.
    """

    @classmethod
    @abstractmethod
    def load_file(cls, pathfile):
        """Instantiate object from a text file.

        :param pathfile: path to file that describes the surface
        :type pathfile: str

        :return: the surface
        :rtype: Surface
        """
        pass

    @abstractmethod
    def _get_n_fp(self):
        """Get the number of field periods.

        :return: number of field periods
        :rtype: int
        """
        pass

    n_fp = property(_get_n_fp)

    @abstractmethod
    def _get_npts(self):
        """Get the number of points in one field period.

        :return: number of points in one field period
        :rtype: int
        """
        pass

    npts = property(_get_npts)

    @abstractmethod
    def _get_nbpts(self):
        """Get the tuple (n_pol, n_tor) of the number of points in one field period.

        :return: tuple (n_pol, n_tor) of the number of points in one field period
        :rtype: tuple (int, int)
        """
        pass

    nbpts = property(_get_nbpts)

    @abstractmethod
    def _get_grids(self):
        """Get ugrid and vgrid.
        """
        pass

    grids = property(_get_grids)

    @abstractmethod
    def _get_P(self):
        """Get all the points of the surface.
        """
        pass

    P = property(_get_P)

    @abstractmethod
    def _get_dpsi(self):
        """Get the derivatives of the (u, v) -> (x, y, z) transformation.
        """
        pass

    dpsi = property(_get_dpsi)

    @abstractmethod
    def _get_dS(self):
        """Get volume element.
        """
        pass

    dS = property(_get_dS)

    @abstractmethod
    def _get_n(self):
        """
        Get the normal inward unit vectors.
        """
        pass

    n = property(_get_n)

    @abstractmethod
    def _get_principles(self):
        """
        Get the principles.
        """
        pass

    principles = property(_get_principles)

    @abstractmethod
    def _get_I(self):
        """
        Get I.
        """
        pass

    I = property(_get_I)

    @abstractmethod
    def _get_dpsi_uu(self):
        """
        Get dpsi_uu.
        """
        pass

    dpsi_uu = property(_get_dpsi_uu)

    @abstractmethod
    def _get_dpsi_uv(self):
        """
        Get dpsi_uv.
        """
        pass

    dpsi_uv = property(_get_dpsi_uv)

    @abstractmethod
    def _get_dpsi_vv(self):
        """
        Get dpsi_vv.
        """
        pass

    dpsi_vv = property(_get_dpsi_vv)

    @abstractmethod
    def _get_II(self):
        """
        Get II.
        """
        pass

    II = property(_get_II)

    @abstractmethod
    def _get_param(self):
        """
        Get the parametrization of the surface.
        """
        pass

    @abstractmethod
    def _set_param(self):
        """
        Set the parametrization of the surface.
        """

    param = property(_get_param, _set_param)

    @abstractmethod
    def get_theta_pertubation(self, compute_curvature):
        """
        Compute the perturbations of a surface
        """
        pass

    @abstractmethod
    def expand_for_plot_part(self):
        """
        Returns 3 arrays X, Y and Z which can be used to plot the surface.
        """
        pass

    def get_B_generated(self, j, pos):
        from src.tools import get_rot_tensor, eijk
        from scipy.constants import mu_0
        from opt_einsum import contract
        from numpy import linalg, pi, einsum, newaxis

        """
        full_j = einsum("opq,ijq->oijp", rot_tensor, j)

        cross = einsum("nuvi,nuvj,ijc->nuvc", full_j,
                       K, tools.eijk, optimize=True)
        cross_dS = einsum("nuvc,uv->nuvc", cross, self.dS)

        B_pos = mu_0 / (4*pi) * einsum("nuvc->c",
                                       cross_dS) / self.npts
        """
        rot_tensor = get_rot_tensor(self.n_fp)

        # pos - x for all x
        T = pos[newaxis, newaxis, newaxis, :] - \
            einsum("opq,ijq->oijp", rot_tensor, self.P)
        # (pos - x) / ||pos - x||^3
        K = T / (linalg.norm(T, axis=-1)**3)[..., newaxis]

        res = mu_0 / (4*pi) * contract("niq,uvq,nuvj,ijc,uv->c", rot_tensor,
                                       j, K, eijk, self.dS) / self.npts

        return res

    def get_B_generated_on_surface(self, other, j):
        from src.tools import get_tensor_distance, get_rot_tensor, eijk
        from numpy import linalg, einsum, pi
        from opt_einsum import contract
        from scipy.constants import mu_0

        rot_tensor = get_rot_tensor(self.n_fp)
        T = get_tensor_distance(self, other, rot_tensor)
        D = 1 / linalg.norm(T, axis=-1)**3
        K = einsum('sijpqa,sijpq->sijpqa', T, D)

        res = mu_0 / (4*pi) * contract("niq,uvq,nuvlmj,ijc,uv->lmc", rot_tensor,
                                       j, K, eijk, self.dS) / self.npts

        return res

    def get_B_normal_generated_on_surface(self, other, j):
        from numpy import einsum
        return einsum("uvc,cuv->uv", self.get_B_generated_on_surface(other, j), other.n)

    def plot(self, representation="wireframe"):
        from mayavi import mlab
        from numpy import zeros, linspace
        mlab.mesh(*self.expand_for_plot_part(),
                  representation=representation, colormap='Wistia')
        mlab.plot3d(linspace(0, 6, 100), zeros(
            100), zeros(100), color=(1, 0, 0))
        mlab.plot3d(zeros(100), linspace(0, 6, 100),
                    zeros(100), color=(0, 1, 0))
        mlab.plot3d(zeros(100), zeros(100),
                    linspace(0, 6, 100), color=(0, 0, 1))
        mlab.show()

    def plot_function_on_surface(self, f):
        from mayavi import mlab
        from numpy import concatenate, zeros, linspace
        fc2 = concatenate((f, f[0:1]), axis=0)
        s = mlab.mesh(*self.expand_for_plot_part(),
                      representation='surface', scalars=fc2)
        mlab.plot3d(linspace(0, 6, 100), zeros(
            100), zeros(100), color=(1, 0, 0))
        mlab.plot3d(zeros(100), linspace(0, 6, 100),
                    zeros(100), color=(0, 1, 0))
        mlab.plot3d(zeros(100), zeros(100),
                    linspace(0, 6, 100), color=(0, 0, 1))
        mlab.colorbar(s, nb_labels=4, label_fmt='%.1E', orientation='vertical')
        mlab.show()
