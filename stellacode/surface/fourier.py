import typing as tp
from os import sep

from jax.typing import ArrayLike
from scipy.io import netcdf_file

from stellacode import np

from .abstract_surface import AbstractSurface


class FourierSurface(AbstractSurface):
    """A class used to represent a toroidal surface with Fourier coefficients

    :param params: (m,n,Rmn,Zmn) 4 lists to parametrize the surface
    :type params: (int[],int[],float[],float[])
    :param nbpts: see :func:`.abstract_surface.Abstract_surface`
    :type nbpts: (int,int)
    :param Np: see `.abstract_surface.Abstract_surface`
    :type Np: int
    """

    mf: ArrayLike
    nf: ArrayLike
    Np: int

    @classmethod
    def from_file(cls, path_surf, n_fp, n_pol, n_tor):
        """This function returns a Surface_Fourier object defined by a file.
        Three kinds of file are currently supported :
        - wout_.nc files generated by VMEC (for plasma surfaces)
        - nescin files generated by regcoil
        - text files (see example in data/li383)

        load file with the format m,n,Rmn,Zmn"""

        if path_surf[-3::] == ".nc":
            f = netcdf_file(path_surf, "r", mmap=False)
            m = np.array(f.variables["xm"][()])
            n = -np.array(f.variables["xn"][()] / n_fp)
            Rmn = np.array(f.variables["rmnc"][()][-1])
            Zmn = np.array(f.variables["zmns"][()][-1])
            f.close()

        elif path_surf.rpartition(sep)[-1][:6:] == "nescin":
            with open(path_surf, "r") as f:
                line = f.readline()
                while "crc" not in line:
                    line = f.readline()
                data = []
                for line in f:
                    data.append(str.split(line))
                adata = np.array(data, dtype="float64")
                m, n, Rmn, Zmn = adata[:, 0], adata[:, 1], adata[:, 2], adata[:, 3]
        else:
            data = []
            with open(path_surf, "r") as f:
                next(f)
                for line in f:
                    data.append(str.split(line))

            adata = np.array(data, dtype="float64")
            m, n, Rmn, Zmn = adata[:, 0], adata[:, 1], adata[:, 2], adata[:, 3]

        params = {"Rmn": Rmn, "Zmn": Zmn}

        return cls(params=params, mf=m, nf=n, nbpts=(n_pol, n_tor), Np=n_fp)

    def get_xyz(self, uv):
        u, v = uv
        tmp = u * self.mf + v * self.nf
        R = np.tensordot(self.params["Rmn"], np.cos(2 * np.pi * tmp), 1)
        Z = np.tensordot(self.params["Zmn"], np.sin(2 * np.pi * tmp), 1)
        phi = 2 * np.pi * v / self.Np
        return np.array([R * np.cos(phi), R * np.sin(phi), Z])


def expand_for_plot(S):
    """from a toroidal_surface surface return X,Y,Z
    and add redundancy of first row"""
    shape = (S.X.shape[0] + 1, S.X.shape[1])
    lst = []
    for elt in [S.X, S.Y, S.Z]:
        new_elt = np.zeros(shape)
        new_elt[:-1, :] = elt
        new_elt[-1, :] = elt[0, :]
        lst.append(new_elt.copy())
    return lst


def plot_function_on_surface(S, f):
    """Plot f the surface given by S.X,S.Y,S.Z"""
    from mayavi import mlab

    X, Y, Z = expand_for_plot(S)
    fc2 = np.concatenate((f, f[0:1, :]), axis=0)
    s = mlab.mesh(X, Y, Z, representation="surface", scalars=fc2)
    mlab.colorbar(s, nb_labels=4, label_fmt="%.1E", orientation="vertical")
    mlab.show()
    return s
