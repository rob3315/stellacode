import typing as tp
from os import sep

from jax.typing import ArrayLike
from scipy.io import netcdf_file

from stellacode import np

from .abstract_surface import AbstractSurface
from .utils import cartesian_to_toroidal


class FourierSurface(AbstractSurface):
    """A class used to represent a toroidal surface with Fourier coefficients

    :param params: (m,n,Rmn,Zmn) 4 lists to parametrize the surface
    :type params: (int[],int[],float[],float[])
    :param nbpts: see :func:`.abstract_surface.Abstract_surface`
    :type nbpts: (int,int)
    :param Np: see `.abstract_surface.Abstract_surface`
    :type Np: int
    """

    mf: ArrayLike
    nf: ArrayLike
    Rmn: ArrayLike
    Zmn: ArrayLike

    trainable_params: tp.List[str] = [
        "Rmn",
        "Zmn",
    ]

    @classmethod
    def from_file(cls, path_surf, n_fp, n_pol, n_tor):
        """This function returns a Surface_Fourier object defined by a file.
        Three kinds of file are currently supported :
        - wout_.nc files generated by VMEC (for plasma surfaces)
        - nescin files generated by regcoil
        - text files (see example in data/li383)

        load file with the format m,n,Rmn,Zmn"""

        if path_surf[-3::] == ".nc":
            f = netcdf_file(path_surf, "r", mmap=False)
            m = np.array(f.variables["xm"][()])
            n = -np.array(f.variables["xn"][()] / n_fp)
            Rmn = np.array(f.variables["rmnc"][()][-1])
            Zmn = np.array(f.variables["zmns"][()][-1])
            f.close()

        elif path_surf.rpartition(sep)[-1][:6:] == "nescin":
            with open(path_surf, "r") as f:
                line = f.readline()
                while "------ Current Surface:" not in line:
                    line = f.readline()
                line = f.readline()
                num_modes = int(f.readline())

                f.readline()
                f.readline()

                data = []
                for _ in range(num_modes):
                    data.append(str.split(f.readline()))
                adata = np.array(data, dtype="float64")
                m, n, Rmn, Zmn = adata[:, 0], adata[:, 1], adata[:, 2], adata[:, 3]

        else:
            data = []
            with open(path_surf, "r") as f:
                next(f)
                for line in f:
                    data.append(str.split(line))

            adata = np.array(data, dtype="float64")
            m, n, Rmn, Zmn = adata[:, 0], adata[:, 1], adata[:, 2], adata[:, 3]

        return cls(
            Rmn=Rmn, Zmn=Zmn, mf=m, nf=n, nbpts=(n_pol, n_tor), num_tor_symmetry=n_fp
        )

    def get_xyz(self, uv):
        angle = 2 * np.pi * (uv[0] * self.mf + uv[1] * self.nf)
        R = np.tensordot(self.Rmn, np.cos(angle), 1)
        Z = np.tensordot(self.Zmn, np.sin(angle), 1)
        phi = 2 * np.pi * uv[1] / self.num_tor_symmetry
        return np.array([R * np.cos(phi), R * np.sin(phi), Z])

    def get_major_radius(self):
        assert self.mf[0] == 0 and self.nf[0] == 0
        return self.Rmn[0]

    def get_minor_radius(self):
        return np.max(self.cartesian_to_toroidal()[:, :, 0])

    def cartesian_to_toroidal(self):
        return cartesian_to_toroidal(
            xyz=self.P,
            tore_radius=self.get_major_radius(),
            height=self.Zmn[0],
        )

    def get_axisymmetric_envelope(self):
        return np.max(self.cartesian_to_toroidal()[:, :, 0], axis=1)
