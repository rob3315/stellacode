from stellacode import np
from os import sep

from scipy.io import netcdf_file
from .abstract_surface import AbstractSurface


class FourierSurface(AbstractSurface):
    """A class used to represent an toroidal surface with Fourier coefficients

    :param surface_parametrization: (m,n,Rmn,Zmn) 4 lists to parametrize the surface
    :type surface_parametrization: (int[],int[],float[],float[])
    :param nbpts: see :func:`.abstract_surface.Abstract_surface`
    :type nbpts: (int,int)
    :param Np: see `.abstract_surface.Abstract_surface`
    :type Np: int
    """

    def __init__(self, surface_parametrization, nbpts, Np):
        self.Np = Np
        self.nbpts = nbpts
        self.npts = nbpts[0] * nbpts[1]
        self.surface_parametrization = surface_parametrization
        self.param = np.concatenate((surface_parametrization[2], surface_parametrization[3]))
        self.compute_surface_attributes()  # computation of the surface attributes

    @classmethod
    def from_file(cls, path_surf, n_fp, n_pol, n_tor):
        """This function returns a Surface_Fourier object defined by a file.
        Three kinds of file are currently supported :
        - wout_.nc files generated by VMEC (for plasma surfaces)
        - nescin files generated by regcoil
        - text files (see example in data/li383)

        load file with the format m,n,Rmn,Zmn"""

        if path_surf[-3::] == ".nc":
            f = netcdf_file(path_surf, "r", mmap=False)
            m = f.variables["xm"][()]
            n = -f.variables["xn"][()] / n_fp
            Rmn = f.variables["rmnc"][()][-1]
            Zmn = f.variables["zmns"][()][-1]
            f.close()

        elif path_surf.rpartition(sep)[-1][:6:] == "nescin":
            with open(path_surf, "r") as f:
                line = f.readline()
                while "crc" not in line:
                    line = f.readline()
                data = []
                for line in f:
                    data.append(str.split(line))
                adata = np.array(data, dtype="float64")
                m, n, Rmn, Zmn = adata[:, 0], adata[:, 1], adata[:, 2], adata[:, 3]
        else:
            data = []
            with open(path_surf, "r") as f:
                next(f)
                for line in f:
                    data.append(str.split(line))

            adata = np.array(data, dtype="float64")
            m, n, Rmn, Zmn = adata[:, 0], adata[:, 1], adata[:, 2], adata[:, 3]

        surface_parametrization = (m, n, Rmn, Zmn)

        return cls(surface_parametrization, (n_pol, n_tor), n_fp)

    def _get_param(self):
        return self.__param

    def _set_param(self, param):
        self.__param = param
        m, n = self.surface_parametrization[0], self.surface_parametrization[1]
        Rmn, Zmn = param[: len(m)], param[len(m) :]
        self.surface_parametrization = (m, n, Rmn, Zmn)
        self.compute_surface_attributes()

    param = property(_get_param, _set_param)

    def change_param(param, dcoeff):
        """from a surface parameters and an array of modification,
        return the right surface parameters"""
        (m, n, Rmn, Zmn) = param
        dR = dcoeff[: len(m)]
        dZ = dcoeff[len(m) :]
        return (m, n, Rmn + dR, Zmn + dZ)

    def get_xyz(self, uv):
        m, n, Rmn, Zmn = self.surface_parametrization
        u, v = uv
        tmp = u * m + v * n
        R = np.tensordot(Rmn, np.cos(2 * np.pi * tmp), 1)
        Z = np.tensordot(Zmn, np.sin(2 * np.pi * tmp), 1)
        phi = 2 * np.pi * v / self.Np
        return np.array([R * np.cos(phi), R * np.sin(phi), Z])


def expand_for_plot(S):
    """from a toroidal_surface surface return X,Y,Z
    and add redundancy of first row"""
    shape = (S.X.shape[0] + 1, S.X.shape[1])
    lst = []
    for elt in [S.X, S.Y, S.Z]:
        new_elt = np.zeros(shape)
        new_elt[:-1, :] = elt
        new_elt[-1, :] = elt[0, :]
        lst.append(new_elt.copy())
    return lst


def plot_function_on_surface(S, f):
    """Plot f the surface given by S.X,S.Y,S.Z"""
    from mayavi import mlab

    X, Y, Z = expand_for_plot(S)
    fc2 = np.concatenate((f, f[0:1, :]), axis=0)
    s = mlab.mesh(X, Y, Z, representation="surface", scalars=fc2)
    mlab.colorbar(s, nb_labels=4, label_fmt="%.1E", orientation="vertical")
    mlab.show()
    return s
