import typing as tp

import jax
from jax.typing import ArrayLike
from pydantic import BaseModel, Extra

from stellacode import np


class AbstractSurface(BaseModel):
    """A class used to:
    * represent an abstract surfaces
    * computate of the magnetic field generated by a current carried by the surface.
    * visualize surfaces
    """

    params: tp.Dict[str, ArrayLike]

    class Config:
        arbitrary_types_allowed = True
        extra = Extra.allow  # allow extra fields

    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        self.npts = self.nbpts[0] * self.nbpts[1]
        self.compute_surface_attributes()  # computation of the surface attributes

    def get_xyz(self, uv):
        """return the point parametrized by uv in cartesian coordinate"""
        raise NotImplementedError

    def update_params(self, **kwargs):
        for k, v in kwargs.items():
            self.params[k] = v
        self.compute_surface_attributes(deg=2)

    def get_uvgrid(self, lu, lv, concat: bool = False):
        # u, v = np.linspace(
        #     0, 1, lu, endpoint=False), (np.arange(lv) + 0.5) / lv
        u, v = np.linspace(0, 1, lu, endpoint=False), np.linspace(0, 1, lv, endpoint=False)
        ugrid, vgrid = np.meshgrid(u, v, indexing="ij")
        if concat:
            return np.stack((ugrid, vgrid), axis=0)
        else:
            return ugrid, vgrid

    def get_xyz_on_grid(self, grid):
        grid_ = np.reshape(grid, (2, -1))
        _, lu, lv = grid.shape
        surf = jax.vmap(self.get_xyz, in_axes=1, out_axes=-1)
        surf_res = surf(grid_)
        lu, lv = self.nbpts
        xyz = np.transpose(np.reshape(surf_res, (3, lu, lv)), (1, 2, 0))
        return xyz

    def get_jac_xyz_on_grid(self, grid):
        grid_ = np.reshape(grid, (2, -1))
        _, lu, lv = grid.shape

        jac_surf = jax.jacobian(self.get_xyz, argnums=0)
        jac_surf_vmap = jax.vmap(jac_surf, in_axes=1, out_axes=-1)
        jac_surf_res = jac_surf_vmap(grid_)
        jac_xyz = np.reshape(np.transpose(jac_surf_res, (1, 0, 2)), (2, 3, lu, lv))
        return jac_xyz

    def get_hess_xyz_on_grid(self, grid):
        grid_ = np.reshape(grid, (2, -1))
        _, lu, lv = grid.shape

        hess_surf = jax.hessian(self.get_xyz, argnums=0, holomorphic=False)
        hess_surf_vmap = jax.vmap(hess_surf, in_axes=1, out_axes=-1)
        hess_surf_res = hess_surf_vmap(grid_)
        return np.reshape(hess_surf_res, (3, 2, 2, lu, lv))

    def compute_surface_attributes(self, deg=2):
        """compute surface elements used in the shape optimization up
        to degree deg
        deg is 0,1 or 2"""

        self.get_uvgrid(*self.nbpts)
        self.grids = self.get_uvgrid(*self.nbpts)

        uv_grid = np.stack(self.grids, axis=0)
        self.P = self.get_xyz_on_grid(uv_grid)

        # We also compute surface element dS and derivatives dS_u and dS_v:
        if deg >= 1:
            self.dpsi = self.get_jac_xyz_on_grid(uv_grid)

            N = np.cross(self.dpsi[0], self.dpsi[1], 0, 0, 0)
            self.N = N
            self.dS = np.linalg.norm(N, axis=0)
            self.n = N / self.dS  # normal inward unit vector

        if deg >= 2:
            hess = self.get_hess_xyz_on_grid(uv_grid)

            self.dpsi_uu = hess[:, 0, 0, ...]
            self.dpsi_uv = hess[:, 1, 1, ...]
            self.dpsi_vv = hess[:, 0, 1, ...]

            dNdu = np.cross(self.dpsi_uu, self.dpsi[1], 0, 0, 0) + np.cross(self.dpsi[0], self.dpsi_uv, 0, 0, 0)
            dNdv = np.cross(self.dpsi_uv, self.dpsi[1], 0, 0, 0) + np.cross(self.dpsi[0], self.dpsi_vv, 0, 0, 0)
            self.dS_u = np.sum(dNdu * N, axis=0) / self.dS
            self.dS_v = np.sum(dNdv * N, axis=0) / self.dS
            self.n_u = dNdu / self.dS - self.dS_u * N / (self.dS**2)
            self.n_v = dNdv / self.dS - self.dS_v * N / (self.dS**2)
            # curvature computation
            # curvature computations :
            # First fundamental form of the surface (E,F,G)
            E = np.einsum("lij,lij->ij", self.dpsi[0], self.dpsi[0])
            F = np.einsum("lij,lij->ij", self.dpsi[0], self.dpsi[1])
            G = np.einsum("lij,lij->ij", self.dpsi[1], self.dpsi[1])
            self.__I = (E, F, G)
            # m=np.cross(self.dpsi[0],self.dpsi[1],axisa=0, axisb=0)
            # p=np.sqrt(np.einsum('ijl,ijl->ij', m, m))
            # n=m/p[:,:,np.newaxis]
            # Second fundamental of the surface (L,M,N)
            L = np.einsum("lij,lij->ij", self.dpsi_uu, self.n)  # e
            M = np.einsum("lij,lij->ij", self.dpsi_uv, self.n)  # f
            N = np.einsum("lij,lij->ij", self.dpsi_vv, self.n)  # g
            self.II = (L, M, N)
            # K = det(second fundamental) / det(first fundamental)
            # Gaussian Curvature
            K = (L * N - M**2) / (E * G - F**2)
            self.K = K
            # trace of (second fundamental)(first fundamental^-1)
            # Mean Curvature
            H = ((E * N + G * L - 2 * F * M) / ((E * G - F**2))) / 2
            self.H = H
            Pmax = H + np.sqrt(H**2 - K)
            Pmin = H - np.sqrt(H**2 - K)
            self.principles = [Pmax, Pmin]

    def get_B_generated(self, j, positions):
        """Returns the B field generated by a current distribution at given positions.
        positions can have any number of axis, but the xyz coordinates of the points must be in the last one.
        j must have the following shape : (n_pol, n_tor, 3)

        :param j: surface current distribution carried by the surface
        :type j: 3D float array

        :param pos: position where we want to compute B
        :type pos: 1D float array

        :return: B field
        :rtype: 1D float array
        """
        import dask.array as da
        from numpy import expand_dims, float64, linalg, newaxis, pi
        from opt_einsum import contract
        from scipy.constants import mu_0

        from stellacode.tools import eijk, get_rot_tensor

        rot_tensor = get_rot_tensor(self.n_fp)

        def compute_B(grid):
            T = grid[newaxis, newaxis, newaxis, ...] - expand_dims(
                contract("opq,ijq->oijp", rot_tensor, self.P),
                axis=tuple(range(3, 2 + len(grid.shape))),
            )

            K = T / (linalg.norm(T, axis=-1) ** 3)[..., newaxis]

            XYZBs = (
                mu_0 / (4 * pi) * contract("niq,uvq,nuv...j,ijc,uv->...c", rot_tensor, j, K, eijk, self.dS) / self.npts
            )

            return XYZBs

        positions_dask = da.from_array(positions, chunks="auto")

        XYZBs = da.map_blocks(compute_B, positions_dask, dtype=float64).compute()

        return XYZBs

    def get_B_generated_on_surface(self, other, j):
        """Returns the B field generated by a current distribution on another surface.
        j must have the following shape : (n_pol, n_tor, 3)

        :param other: surface on which we want to compute B
        :type other: Surface

        :param j: surface current distribution carried by the surface (on one field period)
        :type j: 3D float array

        :return: B field
        :rtype: 3D float array
        """
        import dask.array as da
        from numpy import float64, linalg, newaxis, pi
        from opt_einsum import contract
        from scipy.constants import mu_0

        from stellacode.tools import eijk, get_rot_tensor

        rot_tensor = get_rot_tensor(self.n_fp)

        def compute_B(XYZgrid):
            T = (
                XYZgrid[newaxis, newaxis, newaxis, ...]
                - contract("opq,ijq->oijp", rot_tensor, self.P)[..., newaxis, newaxis, :]
            )

            K = T / (linalg.norm(T, axis=-1) ** 3)[..., newaxis]

            res = mu_0 / (4 * pi) * contract("niq,uvq,nuvlmj,ijc,uv->lmc", rot_tensor, j, K, eijk, self.dS) / self.npts

            return res

        XYZgrid_dask = da.from_array(other.P, chunks=(10, 10, 3))

        B = da.map_blocks(compute_B, XYZgrid_dask, dtype=float64).compute()

        return B

    def get_B_normal_generated_on_surface(self, other, j):
        """Returns the inward  normal B field generated by a current distribution on another surface.
        j must have the following shape : (n_pol, n_tor, 3)

        :param other: surface on which we want to compute B normal
        :type other: Surface

        :param j: surface current distribution carried by the surface
        :type j: 3D float array

        :return: B normal field
        :rtype: 2D float array
        """
        from numpy import einsum

        return einsum("uvc,cuv->uv", self.get_B_generated_on_surface(other, j), other.n)

    def expand_for_plot_part(self):
        """Returns X, Y, Z arrays of one field period, adding redundancy of first column.

        :return: X, Y, Z arrays
        :rtype: tuple(2D array, 2D array, 2D array)
        """
        from stellacode import np

        shape = self.P.shape[0] + 1, self.P.shape[1]

        X, Y, Z = np.empty(shape), np.empty(shape), np.empty(shape)
        X[:-1:, ::] = self.P[..., 0]
        X[-1, ::] = self.P[0, ::, 0]
        Y[:-1:, ::] = self.P[..., 1]
        Y[-1, ::] = self.P[0, ::, 1]
        Z[:-1:, ::] = self.P[..., 2]
        Z[-1, ::] = self.P[0, ::, 2]

        return X, Y, Z

    def expand_for_plot_whole(self):
        """Returns X, Y, Z arrays of the whole Stellarator.

        :return: X, Y, Z arrays
        :rtype: tuple(2D array, 2D array, 2D array)
        """
        from stellacode import np

        X, Y, Z = self.expand_for_plot_part()
        points = np.stack((X, Y, Z), axis=-1)

        for i in range(1, self.n_fp):
            angle = 2 * i * np.pi / self.n_fp
            rotation_matrix = np.array(
                [
                    [np.cos(angle), -np.sin(angle), 0],
                    [np.sin(angle), np.cos(angle), 0],
                    [0, 0, 1],
                ]
            )
            rotated_points = np.einsum("ij,uvj->uvi", rotation_matrix, points)
            X = np.concatenate((X, rotated_points[..., 0]), axis=1)
            Y = np.concatenate((Y, rotated_points[..., 1]), axis=1)
            Z = np.concatenate((Z, rotated_points[..., 2]), axis=1)

        return (
            np.concatenate((X, X[:, 0][:, np.newaxis]), axis=1),
            np.concatenate((Y, Y[:, 0][:, np.newaxis]), axis=1),
            np.concatenate((Z, Z[:, 0][:, np.newaxis]), axis=1),
        )

    def plot_whole_surface(self, representation="surface"):
        """Plots the whole surface.

        :return: None
        :rtype: NoneType
        """
        from mayavi import mlab

        from stellacode import np

        mlab.mesh(*self.expand_for_plot_whole(), representation=representation, colormap="Wistia")
        mlab.plot3d(np.linspace(0, 10, 100), np.zeros(100), np.zeros(100), color=(1, 0, 0))
        mlab.plot3d(np.zeros(100), np.linspace(0, 10, 100), np.zeros(100), color=(0, 1, 0))
        mlab.plot3d(np.zeros(100), np.zeros(100), np.linspace(0, 10, 100), color=(0, 0, 1))
        mlab.show()

    def plot(self, representation="wireframe"):
        """Plots one field period of the surface.

        :return: None
        :rtype: NoneType
        """
        from mayavi import mlab
        from numpy import linspace, zeros

        mlab.mesh(*self.expand_for_plot_part(), representation=representation, colormap="Wistia")
        mlab.plot3d(linspace(0, 6, 100), zeros(100), zeros(100), color=(1, 0, 0))
        mlab.plot3d(zeros(100), linspace(0, 6, 100), zeros(100), color=(0, 1, 0))
        mlab.plot3d(zeros(100), zeros(100), linspace(0, 6, 100), color=(0, 0, 1))
        mlab.show()

    def plot_function_on_surface(self, f):
        """Plots a scalar function on the surface.

        :return: None
        :rtype: NoneType
        """
        from mayavi import mlab
        from numpy import concatenate, linspace, zeros

        fc2 = concatenate((f, f[0:1]), axis=0)
        s = mlab.mesh(*self.expand_for_plot_part(), representation="surface", scalars=fc2)
        mlab.plot3d(linspace(0, 6, 100), zeros(100), zeros(100), color=(1, 0, 0))
        mlab.plot3d(zeros(100), linspace(0, 6, 100), zeros(100), color=(0, 1, 0))
        mlab.plot3d(zeros(100), zeros(100), linspace(0, 6, 100), color=(0, 0, 1))
        mlab.colorbar(s, nb_labels=4, label_fmt="%.1E", orientation="vertical")
        mlab.show()
