import collections
import typing as tp

import jax
from jax.typing import ArrayLike
from pydantic import BaseModel, Extra

import stellacode.tools as tools
from stellacode import np
from stellacode.tools.utils import get_min_dist

from .coil_surface import CoilSurface


class RotatedSurface(CoilSurface):
    """A class used to:
    * represent an abstract surfaces
    * computate of the magnetic field generated by a current carried by the surface.
    * visualize surfaces
    """

    num_tor_symmetry: int = 1
    rotate_diff_current: int = 1

    def get_num_rotations(self):
        return self.num_tor_symmetry * self.rotate_diff_current

    def get_trainable_params(self):
        return self.surface.get_trainable_params()

    def update_params(self, **kwargs):
        for k, v in kwargs.items():
            setattr(self.surface, k, v)
        self.compute_surface_attributes(deg=2)

    def get_curent_potential_op(self):
        curent_potential_op = self.current.get_matrix_from_grid(self.surface.grids)

        inner_blocks = collections.deque(
            [curent_potential_op]
            + [np.zeros_like(curent_potential_op)] * (self.rotate_diff_current - 1)
        )
        blocks = []
        for i in range(len(inner_blocks)):
            blocks.append(np.concatenate(inner_blocks, axis=0))

            inner_blocks.rotate(1)
        blocks = np.concatenate(
            blocks,
            axis=1,
        )

        return np.concatenate([blocks] * self.num_tor_symmetry, axis=1)

    def compute_surface_attributes(self, deg=2):
        """compute surface elements used in the shape optimization up
        to degree deg
        deg is 0,1 or 2"""
        self.surface.compute_surface_attributes(deg=deg)

        num_rot = self.get_num_rotations()
        rot_tensor = tools.get_rot_tensor(num_rot)
        self.grids = self.surface.grids
        self.P = np.reshape(
            np.einsum("opq,ijq->oijp", rot_tensor, self.surface.P),
            (-1, self.surface.nbpts[1], 3),
        )

        # We also compute surface element dS and derivatives dS_u and dS_v:
        if deg >= 1:
            self.dpsi = np.reshape(
                np.einsum("opq,aqij->oijpa", rot_tensor, self.surface.dpsi),
                (-1, self.surface.nbpts[1], 3, 2),
            )
            "sba,taij->sijbt"
            # import pdb;pdb.set_trace()
            self.N = np.reshape(
                np.einsum("opq,qij->poij", rot_tensor, self.surface.N),
                (3, -1, self.surface.nbpts[1]),
            )

            self.dS = np.concatenate([self.surface.dS] * num_rot, axis=0)

            self.n = np.reshape(
                np.einsum("opq,qij->poij", rot_tensor, self.surface.n),
                (3, -1, self.surface.nbpts[1]),
            )

        if deg >= 2:
            self.principles = [
                np.concatenate([p] * num_rot) for p in self.surface.principles
            ]
        self.npts = self.surface.npts
        self.nbpts = self.surface.nbpts

    def get_min_distance(self, xyz):
        return get_min_dist(self.P, xyz)

    def fit_to_surface(self, surface):
        # Tries to find approximately the smallest surface enclosing the given surface
        # assuming the given surface has get_major_radius and get_minor_radius methods

        major_radius = surface.get_major_radius()
        minor_radius = surface.get_minor_radius()
        fit_surf = self.copy()
        fit_surf.update_params(
            radius=minor_radius + major_radius / 3,
            distance=major_radius)
        # fit_surf.surface = fit_surf.surface.copy(
        #     update=dict(
        #         radius=minor_radius + major_radius / 3,
        #         distance=major_radius,
        #     )
        # )

        fit_surf.compute_surface_attributes(deg=0)
        min_dist = fit_surf.get_min_distance(surface.P)

        # fit_surf.surface = fit_surf.surface.copy(
        #     update=dict(
        #         radius=minor_radius + major_radius / 3 - min_dist,
        #         distance=major_radius,
        #     )
        # )
        fit_surf.update_params(
            radius=minor_radius + major_radius / 3 - min_dist,
            distance=major_radius)
        fit_surf.compute_surface_attributes()

        return fit_surf
